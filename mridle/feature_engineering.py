import pandas as pd
import numpy as np
import pgeocode


def identify_end_times(row: pd.DataFrame) -> pd.datetime:
    """
    Identify end times of show appts. Could be used like this:
      status_df['end_time'] = status_df.apply(identify_end_times, axis=1)
      status_df['end_time'] = status_df.groupby('FillerOrderNo')['end_time'].fillna(method='bfill')

    Args:
        row: row: A row from a database, as generated by using df.apply(axis=1).

    Returns: appt end datetime, or None if the row is not an appt ending event.

    """
    if row['now_status'] == 'examined':
        return row['date']
    else:
        return None


def feature_scheduled_for_hour(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the sched_for_hour feature to the dataframe uisng was_sched_for_date.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'sched_for_hour'.
    """
    status_df['sched_for_hour'] = status_df['was_sched_for_date'].dt.hour
    return status_df


def identify_sched_events(row: pd.DataFrame) -> pd.datetime:
    """
    Identify scheduling events, for use in feature_days_scheduled_in_advance.

    Args:
        row: row: A row from a database, as generated by using df.apply(axis=1).

    Returns: scheduleing datetime, or None if the row is not a scheduling event.

    """
    if row['was_sched_for'] != row['now_sched_for']:
        return row['now_sched_for']
    else:
        return None


def feature_days_scheduled_in_advance(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the days_sched_in_advance feature to the dataframe.
    Works by identifying status changes that represent scheduling events, and forward filling those dates so that
      'show' and 'no-show' appt status rows contain the date of the most recent scheduling event.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'days_sched_in_advance'.
    """
    status_df['days_sched_in_advance'] = status_df.apply(identify_sched_events, axis=1)
    status_df['days_sched_in_advance'] = status_df.groupby('FillerOrderNo')['days_sched_in_advance'].fillna(
        method='ffill')
    return status_df


def feature_day_of_week(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the day_of_week feature to the dataframe.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'day_of_week'.

    """
    status_df['day_of_week'] = status_df['was_sched_for_date'].dt.dayofweek
    return status_df


def feature_modality(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the modality feature to the dataframe.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'marital'.

    """
    status_df['modality'] = status_df['UniversalServiceName']
    return status_df


def feature_marital(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Label teh Zivilstand of the patient in English.
    Mapping from https://de.wikipedia.org/wiki/Familienstand

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'marital'.

    """
    zivilstand_abbreviation_mapping = {
        'VRH': 'married',
        'LED': 'single',
        'GES': 'divorced',
        'UNB': 'not known',
        'VRW': 'widowed',
        'GTR': 'unable to translate',
        'PAR': 'partnership',
        # 'EA': 'marriage canceled',
        # 'LP': 'in registered civil partnership',
        # 'LV': 'life partnership dissolved by death',
        # 'LA': 'forcible partnership',
        # 'LE': 'civil partnership dissolved by declaration of death',
        np.NaN: 'blank',
    }
    status_df['marital'] = status_df['Zivilstand'].apply(lambda x: zivilstand_abbreviation_mapping[x])
    return status_df


def feature_distance_to_usz(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Calculate distance between the patient's home post code and the post code of the hospital.
    Note: this is slow!! 6:30 minutes for 3 month dataset

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'distance_to_usz'.
    """
    dist = pgeocode.GeoDistance('ch')
    usz_post_code = '8091'
    status_df['WohnadrPLZ_str'] = status_df['WohnadrPLZ'].astype(str)
    status_df['distance_to_usz'] = status_df['WohnadrPLZ_str'].apply(lambda x: dist.query_postal_code(x, usz_post_code))
    return status_df


def feature_historic_no_show_count(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    The number of no-shows the patient has had up to up and _including_ this one.
    Historic no show counts are limited to the bounds of the dataset- it does not include no-shows not included in the
     present dataset.
    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'historic_no_show_cnt'.

    """
    status_df['historic_no_show_cnt'] = status_df.groupby('MRNCmpdId')['NoShow'].cumsum()
    return status_df


def build_harvey_et_al_features_set(status_df: pd.DataFrame, drop_id_col=True) -> pd.DataFrame:
    """
    Builds a feature set that replicates the Harvey et al model as best we can.
    So far includes:
        - days_sched_in_advance: Number of days the appt was scheduled in advance
        - day_of_week: The day of the week of the appt (1=Monday)
        - modality: The UniversalServiceName of the appt
        - marital: Zivilstand of the patient
        - distance_to_usz: distance from the patient's home address to the hospital, approximated from Post Codes
        - historic_no_show_cnt: The number of no shows the patient has had up to the date of the appt
    Args:
        status_df:
        drop_id_col:

    Returns:

    """
    status_df = status_df.sort_values(['FillerOrderNo', 'date'])

    status_df = feature_scheduled_for_hour(status_df)
    status_df = feature_days_scheduled_in_advance(status_df)
    status_df = feature_day_of_week(status_df)
    status_df = feature_modality(status_df)
    status_df = feature_marital(status_df)
    status_df = feature_distance_to_usz(status_df)
    status_df = feature_historic_no_show_count(status_df)

    # re-shape into slot_df
    status_df = status_df.sort_values(['FillerOrderNo', 'date'])
    show_slot_status_events = status_df[(status_df['PatientClass'] == 'ambulent') & (status_df['OrderStatus'] == 'u') &
                                        (status_df['now_status'] == 'started')].copy()
    no_show_slot_status_events = status_df[status_df['NoShow']].copy()

    agg_dict = {
        'NoShow': 'min',
        'sched_for_hour': 'first',
        'days_sched_in_advance': 'first',
        'modality': 'last',
        'day_of_week': 'last',
        'marital': 'last',
        'distance_to_usz': 'last',
        'historic_no_show_cnt': 'last',
    }

    # there should be one show appt per FillerOrderNo
    show_slot_df = show_slot_status_events.groupby(['FillerOrderNo']).agg(agg_dict).reset_index()

    # there may be multiple no-show appts per FillerOrderNo
    no_show_slot_df = no_show_slot_status_events.groupby(['FillerOrderNo', 'was_sched_for_date']).agg(
        agg_dict).reset_index()
    no_show_slot_df.drop('was_sched_for_date', axis=1, inplace=True)

    new_slot_df = pd.concat([show_slot_df, no_show_slot_df])

    if drop_id_col:
        new_slot_df.drop('FillerOrderNo', axis=1, inplace=True)

    return new_slot_df
