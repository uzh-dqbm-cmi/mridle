import datetime as dt
import pandas as pd
import numpy as np
import pgeocode
from mridle.data_management import build_slot_df


def identify_end_times(row: pd.DataFrame) -> dt.datetime:
    """
    Identify end times of show appts. Could be used like this:
      status_df['end_time'] = status_df.apply(identify_end_times, axis=1)
      status_df['end_time'] = status_df.groupby('FillerOrderNo')['end_time'].fillna(method='bfill')

    Args:
        row: row from a database, as generated by using df.apply(axis=1).

    Returns: appt end datetime, or None if the row is not an appt ending event.

    """
    if row['now_status'] == 'examined':
        return row['date']
    else:
        return None


def feature_scheduled_for_hour(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the sched_for_hour feature to the dataframe uisng was_sched_for_date.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'sched_for_hour'.
    """
    status_df['sched_for_hour'] = status_df['was_sched_for_date'].dt.hour
    return status_df


def identify_sched_events(row: pd.DataFrame) -> dt.datetime:
    """
    Identify scheduling events, for use in feature_days_scheduled_in_advance.

    Args:
        row: row: A row from a database, as generated by using df.apply(axis=1).

    Returns: scheduleing datetime, or None if the row is not a scheduling event.

    """
    if row['was_sched_for'] != row['now_sched_for']:
        return row['now_sched_for']
    else:
        return None


def feature_days_scheduled_in_advance(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the days_sched_in_advance feature to the dataframe.
    Works by identifying status changes that represent scheduling events, and forward filling those dates so that
      'show' and 'no-show' appt status rows contain the date of the most recent scheduling event.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'days_sched_in_advance'.
    """
    status_df['days_sched_in_advance'] = status_df.apply(identify_sched_events, axis=1)
    status_df['days_sched_in_advance'] = status_df.groupby('FillerOrderNo')['days_sched_in_advance'].fillna(
        method='ffill')
    return status_df


def feature_day_of_week(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the day_of_week feature to the dataframe.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'day_of_week'.

    """
    status_df['day_of_week'] = status_df['was_sched_for_date'].dt.dayofweek
    return status_df


def feature_modality(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Append the modality feature to the dataframe.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'marital'.

    """
    status_df['modality'] = status_df['UniversalServiceName']
    return status_df


def feature_insurance_class(status_df: pd.DataFrame) -> pd.DataFrame:
    insurance_class_map = {
        'A': 'general',
        'P': 'private',
        'HP': 'half private',
    }
    status_df['insurance_class'] = status_df['Klasse'].apply(lambda x: insurance_class_map.get(x, 'unknown'))
    return status_df


def feature_sex(status_df: pd.DataFrame) -> pd.DataFrame:
    gender_map = {
        'weiblich': 'female',
        'mÃ¤nnlich': 'male',
        'unbekannt': 'unknown',
    }
    status_df['sex'] = status_df['Sex'].apply(lambda x: gender_map.get(x, 'unknown'))
    return status_df


def feature_age(status_df: pd.DataFrame) -> pd.DataFrame:
    status_df['age'] = pd.to_datetime(status_df['date']).dt.year - pd.to_datetime(status_df['DateOfBirth']).dt.year
    return status_df


def feature_marital(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Label teh Zivilstand of the patient in English.
    Mapping from https://de.wikipedia.org/wiki/Familienstand

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'marital'.

    """
    zivilstand_abbreviation_mapping = {
        'VRH': 'married',
        'LED': 'single',
        'GES': 'divorced',
        'UNB': 'not known',
        'VRW': 'widowed',
        'GTR': 'unable to translate',
        'PAR': 'partnership',
        # 'EA': 'marriage canceled',
        # 'LP': 'in registered civil partnership',
        # 'LV': 'life partnership dissolved by death',
        # 'LA': 'forcible partnership',
        # 'LE': 'civil partnership dissolved by declaration of death',
        np.NaN: 'blank',
    }
    status_df['marital'] = status_df['Zivilstand'].apply(lambda x: zivilstand_abbreviation_mapping[x])
    return status_df


def feature_post_code(status_df: pd.DataFrame) -> pd.DataFrame:
    status_df['post_code'] = status_df['Zip']
    return status_df


def feature_distance_to_usz(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    Calculate distance between the patient's home post code and the post code of the hospital.

    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'distance_to_usz'.
    """
    dist = pgeocode.GeoDistance('ch')
    usz_post_code = '8091'
    status_df['Zip'] = status_df['Zip'].astype(str)

    unique_zips = pd.DataFrame(status_df['Zip'].unique(), columns=['Zip'])
    unique_zips['distance_to_usz'] = unique_zips['Zip'].apply(lambda x: dist.query_postal_code(x, usz_post_code))
    status_df = pd.merge(status_df, unique_zips, on='Zip', how='left')
    return status_df


def feature_historic_no_show_count(status_df: pd.DataFrame) -> pd.DataFrame:
    """
    The number of no-shows the patient has had up to up and _including_ this one.
    Historic no show counts are limited to the bounds of the dataset- it does not include no-shows not included in the
     present dataset.
    Args:
        status_df: A row-per-status-change dataframe.

    Returns: A row-per-status-change dataframe with additional column 'historic_no_show_cnt'.

    """
    status_df['historic_no_show_cnt'] = status_df.groupby('MRNCmpdId')['NoShow'].cumsum()
    return status_df


def build_harvey_et_al_features_set(status_df: pd.DataFrame, include_id_cols=False) -> pd.DataFrame:
    """
    Builds a feature set that replicates the Harvey et al model as best we can.
    So far includes:
        - days_sched_in_advance: Number of days the appt was scheduled in advance
        - day_of_week: The day of the week of the appt (1=Monday)
        - modality: The UniversalServiceName of the appt
        - marital: Zivilstand of the patient
        - distance_to_usz: distance from the patient's home address to the hospital, approximated from Post Codes
        - historic_no_show_cnt: The number of no shows the patient has had up to the date of the appt
    Args:
        status_df:
        drop_id_col:

    Returns:

    """
    status_df = status_df.sort_values(['FillerOrderNo', 'date'])

    status_df = feature_scheduled_for_hour(status_df)
    status_df = feature_days_scheduled_in_advance(status_df)
    status_df = feature_day_of_week(status_df)
    status_df = feature_modality(status_df)
    status_df = feature_insurance_class(status_df)
    status_df = feature_sex(status_df)
    status_df = feature_age(status_df)
    status_df = feature_marital(status_df)
    status_df = feature_post_code(status_df)
    status_df = feature_distance_to_usz(status_df)
    status_df = feature_historic_no_show_count(status_df)

    agg_dict = {
        'NoShow': 'min',
        'sched_for_hour': 'first',
        'days_sched_in_advance': 'first',
        'modality': 'last',
        'insurance_class': 'last',
        'day_of_week': 'last',
        'sex': 'last',
        'age': 'last',
        'marital': 'last',
        'post_code': 'last',
        'distance_to_usz': 'last',
        'historic_no_show_cnt': 'last',
    }

    slot_df = build_slot_df(status_df, agg_dict, include_id_cols=include_id_cols)

    return slot_df
